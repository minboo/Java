# 1.背景
**例子：创建个窗口卖票，总票数为100张.使用实现Runnable接口的方式**

* 1.问题：卖票过程中，出现了重票、错票 -->出现了线程的安全问题


* 2.问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。


* 3.如何解决：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。

# 2.Java解决方案：同步机制

**在Java中，我们通过同步机制，来解决线程的安全问题。**

**方式一：同步代码块**
```java
   synchronized(同步监视器){
      //需要被同步的代码

   }
```
**说明：**

* 1.操作共享数据的代码，即为需要被同步的代码。  -->不能包含代码多了，也不能包含代码少了。


* 2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。


* 3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。


 **要求：多个线程必须要共用同一把锁。**

**补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。
       在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。**

**方式二：同步方法**

* 如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。

**关于同步方法的总结：**
* 1.同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。


* 2.非静态的同步方法，同步监视器是：this


* 3.静态的同步方法，同步监视器是：当前类本身

**方式三：Lock锁  --- JDK5.0新增**


**使用的优先顺序：**
* Lock ---> 同步代码块（已经进入了方法体，分配了相应资源 ) ---> 同步方法（在方法体之外)
# 3.利弊

**同步的方式，解决了线程的安全问题。---好处**

**操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。**



